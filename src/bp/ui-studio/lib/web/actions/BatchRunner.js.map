{"version":3,"sources":["../../../src/web/actions/BatchRunner.js"],"names":["Promise","BatchRunner","execute","maxQueue","maxInterval","queue","promises","run","length","ids","then","resources","id","resolve","catch","err","reject","add","resourceId","promise","push","p","intervalId","setInterval","destroy","clearInterval"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,UAApB;;AAEA;AACA;AACA;AACA,MAAMC,cAAc,CAACC,OAAD,EAAU,EAAEC,WAAW,GAAb,EAAkBC,cAAc,EAAhC,KAAuC,EAAjD,KAAwD;AAC1E,MAAIC,QAAQ,EAAZ;AACA,QAAMC,WAAW,EAAjB;;AAEA,QAAMC,MAAM,MAAM;AAChB,QAAI,CAACF,MAAMG,MAAX,EAAmB;AACjB;AACD;AACD,UAAMC,MAAMJ,KAAZ;AACAA,YAAQ,EAAR;;AAEAH,YAAQO,GAAR,EACGC,IADH,CACQC,aAAa;AACjB,WAAK,MAAMC,EAAX,IAAiBH,GAAjB,EAAsB;AACpBH,iBAASM,EAAT,EAAaC,OAAb,CAAqBF,UAAUC,EAAV,CAArB;AACA,eAAON,SAASM,EAAT,CAAP;AACD;AACF,KANH,EAOGE,KAPH,CAOSC,OAAO;AACZ,WAAK,MAAMH,EAAX,IAAiBH,GAAjB,EAAsB;AACpBH,iBAASM,EAAT,EAAaI,MAAb,CAAoBD,GAApB;AACA,eAAOT,SAASM,EAAT,CAAP;AACD;AACF,KAZH;AAaD,GApBD;;AAsBA,QAAMK,MAAMC,cAAc;AACxB;AACA,QAAIZ,SAASY,UAAT,CAAJ,EAA0B;AACxB,aAAOZ,SAASY,UAAT,EAAqBC,OAA5B;AACD;;AAEDd,UAAMe,IAAN,CAAWF,UAAX;AACA,UAAMG,IAAI,IAAIrB,OAAJ,CAAY,CAACa,OAAD,EAAUG,MAAV,KAAqB;AACzCV,eAASY,UAAT,IAAuB,EAAEL,OAAF,EAAWG,MAAX,EAAvB;AACD,KAFS,CAAV;AAGAV,aAASY,UAAT,EAAqBC,OAArB,GAA+BE,CAA/B;;AAEA;AACA,QAAIhB,MAAMG,MAAN,IAAgBL,QAApB,EAA8B;AAC5BI;AACD;;AAED,WAAOc,CAAP;AACD,GAlBD;;AAoBA;AACA,QAAMC,aAAaC,YAAYhB,GAAZ,EAAiBH,WAAjB,CAAnB;;AAEA,QAAMoB,UAAU,MAAM;AACpBC,kBAAcH,UAAd;AACD,GAFD;;AAIA,SAAO,EAAEL,GAAF,EAAOO,OAAP,EAAP;AACD,CAtDD;;AAwDA,eAAevB,WAAf","file":"BatchRunner.js","sourcesContent":["import Promise from 'bluebird'\n\n// `execute` must be a function accepting an array of resource IDs\n// and returning a promise resolving to an object mapping\n// from ID to the data object\nconst BatchRunner = (execute, { maxQueue = 100, maxInterval = 20 } = {}) => {\n  let queue = []\n  const promises = {}\n\n  const run = () => {\n    if (!queue.length) {\n      return\n    }\n    const ids = queue\n    queue = []\n\n    execute(ids)\n      .then(resources => {\n        for (const id of ids) {\n          promises[id].resolve(resources[id])\n          delete promises[id]\n        }\n      })\n      .catch(err => {\n        for (const id of ids) {\n          promises[id].reject(err)\n          delete promises[id]\n        }\n      })\n  }\n\n  const add = resourceId => {\n    // don't fetch the same resource twice\n    if (promises[resourceId]) {\n      return promises[resourceId].promise\n    }\n\n    queue.push(resourceId)\n    const p = new Promise((resolve, reject) => {\n      promises[resourceId] = { resolve, reject }\n    })\n    promises[resourceId].promise = p\n\n    // drain the queue when the max length is reached\n    if (queue.length >= maxQueue) {\n      run()\n    }\n\n    return p\n  }\n\n  // drain the queue on a regular basis\n  const intervalId = setInterval(run, maxInterval)\n\n  const destroy = () => {\n    clearInterval(intervalId)\n  }\n\n  return { add, destroy }\n}\n\nexport default BatchRunner\n"]}