//CHECKSUM:799d42af97c2747d2ff20053d727696ab082eeddc5b1d9d47022980314b549f4
"use strict";

const _ = require('lodash');
/**
 * Appends the provided context(s) to the list of contexts that will be used by the NLU Engine
 * for the next messages for that chat session.
 *
 * The TTL (Time-To-Live) represents how long the contexts will be valid for before they are automatically removed.
 * For example, the default value of `1` will listen for that context only once (the next time the user speaks).
 *
 * If a context was already present in the list, the higher TTL will win.
 * To force override a specific context, use the `removeContext` action before this action.
 *
 * This method is contextual to the current user and chat session.
 *
 * You can specify more than one context by separating them with a comma.
 *
 * @title Append Context
 * @category NLU
 * @author Botpress, Inc.
 * @param {string} contexts - Comma-separated list of contextss
 * @param {string} [ttl=1] - Time-To-Live of the context in number of dialog turns. Put `0` to disable expiry.
 */


const appendContext = (contexts, ttl) => {
  const existing = event.state.session.nluContexts || [];
  const add = contexts.split(',');
  const merged = [...existing, ...add.map(x => ({
    context: x,
    ttl: isNaN(Number(ttl)) ? 1000 : Number(ttl)
  }))];
  const final = [];
  const visited = {};

  for (const ctx of merged) {
    if (visited[ctx.context]) {
      continue;
    }

    final.push(_.chain(merged).filter(x => x.context === ctx.context).orderBy('ttl', 'desc').first().value());
    visited[ctx.context] = true;
  }

  event.state.session.nluContexts = final;
};

return appendContext(args.contexts, args.ttl);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFwcGVuZENvbnRleHQuanMiXSwibmFtZXMiOlsiXyIsInJlcXVpcmUiLCJhcHBlbmRDb250ZXh0IiwiY29udGV4dHMiLCJ0dGwiLCJleGlzdGluZyIsImV2ZW50Iiwic3RhdGUiLCJzZXNzaW9uIiwibmx1Q29udGV4dHMiLCJhZGQiLCJzcGxpdCIsIm1lcmdlZCIsIm1hcCIsIngiLCJjb250ZXh0IiwiaXNOYU4iLCJOdW1iZXIiLCJmaW5hbCIsInZpc2l0ZWQiLCJjdHgiLCJwdXNoIiwiY2hhaW4iLCJmaWx0ZXIiLCJvcmRlckJ5IiwiZmlyc3QiLCJ2YWx1ZSIsImFyZ3MiXSwibWFwcGluZ3MiOiI7O0FBQUEsTUFBTUEsQ0FBQyxHQUFHQyxPQUFPLENBQUMsUUFBRCxDQUFqQjtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JBLE1BQU1DLGFBQWEsR0FBRyxDQUFDQyxRQUFELEVBQVdDLEdBQVgsS0FBbUI7QUFDdkMsUUFBTUMsUUFBUSxHQUFHQyxLQUFLLENBQUNDLEtBQU4sQ0FBWUMsT0FBWixDQUFvQkMsV0FBcEIsSUFBbUMsRUFBcEQ7QUFDQSxRQUFNQyxHQUFHLEdBQUdQLFFBQVEsQ0FBQ1EsS0FBVCxDQUFlLEdBQWYsQ0FBWjtBQUNBLFFBQU1DLE1BQU0sR0FBRyxDQUNiLEdBQUdQLFFBRFUsRUFFYixHQUFHSyxHQUFHLENBQUNHLEdBQUosQ0FBUUMsQ0FBQyxLQUFLO0FBQ2ZDLElBQUFBLE9BQU8sRUFBRUQsQ0FETTtBQUVmVixJQUFBQSxHQUFHLEVBQUVZLEtBQUssQ0FBQ0MsTUFBTSxDQUFDYixHQUFELENBQVAsQ0FBTCxHQUFxQixJQUFyQixHQUE0QmEsTUFBTSxDQUFDYixHQUFEO0FBRnhCLEdBQUwsQ0FBVCxDQUZVLENBQWY7QUFRQSxRQUFNYyxLQUFLLEdBQUcsRUFBZDtBQUNBLFFBQU1DLE9BQU8sR0FBRyxFQUFoQjs7QUFDQSxPQUFLLE1BQU1DLEdBQVgsSUFBa0JSLE1BQWxCLEVBQTBCO0FBQ3hCLFFBQUlPLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDTCxPQUFMLENBQVgsRUFBMEI7QUFDeEI7QUFDRDs7QUFDREcsSUFBQUEsS0FBSyxDQUFDRyxJQUFOLENBQ0VyQixDQUFDLENBQUNzQixLQUFGLENBQVFWLE1BQVIsRUFDR1csTUFESCxDQUNVVCxDQUFDLElBQUlBLENBQUMsQ0FBQ0MsT0FBRixLQUFjSyxHQUFHLENBQUNMLE9BRGpDLEVBRUdTLE9BRkgsQ0FFVyxLQUZYLEVBRWtCLE1BRmxCLEVBR0dDLEtBSEgsR0FJR0MsS0FKSCxFQURGO0FBT0FQLElBQUFBLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDTCxPQUFMLENBQVAsR0FBdUIsSUFBdkI7QUFDRDs7QUFFRFQsRUFBQUEsS0FBSyxDQUFDQyxLQUFOLENBQVlDLE9BQVosQ0FBb0JDLFdBQXBCLEdBQWtDUyxLQUFsQztBQUNELENBNUJEOztBQThCQSxPQUFPaEIsYUFBYSxDQUFDeUIsSUFBSSxDQUFDeEIsUUFBTixFQUFnQndCLElBQUksQ0FBQ3ZCLEdBQXJCLENBQXBCIiwic291cmNlUm9vdCI6Ii9Wb2x1bWVzL2JwL2JvdHByZXNzL21vZHVsZXMvYnVpbHRpbi9zcmMvYmFja2VuZCIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IF8gPSByZXF1aXJlKCdsb2Rhc2gnKVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIHByb3ZpZGVkIGNvbnRleHQocykgdG8gdGhlIGxpc3Qgb2YgY29udGV4dHMgdGhhdCB3aWxsIGJlIHVzZWQgYnkgdGhlIE5MVSBFbmdpbmVcbiAqIGZvciB0aGUgbmV4dCBtZXNzYWdlcyBmb3IgdGhhdCBjaGF0IHNlc3Npb24uXG4gKlxuICogVGhlIFRUTCAoVGltZS1Uby1MaXZlKSByZXByZXNlbnRzIGhvdyBsb25nIHRoZSBjb250ZXh0cyB3aWxsIGJlIHZhbGlkIGZvciBiZWZvcmUgdGhleSBhcmUgYXV0b21hdGljYWxseSByZW1vdmVkLlxuICogRm9yIGV4YW1wbGUsIHRoZSBkZWZhdWx0IHZhbHVlIG9mIGAxYCB3aWxsIGxpc3RlbiBmb3IgdGhhdCBjb250ZXh0IG9ubHkgb25jZSAodGhlIG5leHQgdGltZSB0aGUgdXNlciBzcGVha3MpLlxuICpcbiAqIElmIGEgY29udGV4dCB3YXMgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBsaXN0LCB0aGUgaGlnaGVyIFRUTCB3aWxsIHdpbi5cbiAqIFRvIGZvcmNlIG92ZXJyaWRlIGEgc3BlY2lmaWMgY29udGV4dCwgdXNlIHRoZSBgcmVtb3ZlQ29udGV4dGAgYWN0aW9uIGJlZm9yZSB0aGlzIGFjdGlvbi5cbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBjb250ZXh0dWFsIHRvIHRoZSBjdXJyZW50IHVzZXIgYW5kIGNoYXQgc2Vzc2lvbi5cbiAqXG4gKiBZb3UgY2FuIHNwZWNpZnkgbW9yZSB0aGFuIG9uZSBjb250ZXh0IGJ5IHNlcGFyYXRpbmcgdGhlbSB3aXRoIGEgY29tbWEuXG4gKlxuICogQHRpdGxlIEFwcGVuZCBDb250ZXh0XG4gKiBAY2F0ZWdvcnkgTkxVXG4gKiBAYXV0aG9yIEJvdHByZXNzLCBJbmMuXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dHMgLSBDb21tYS1zZXBhcmF0ZWQgbGlzdCBvZiBjb250ZXh0c3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdHRsPTFdIC0gVGltZS1Uby1MaXZlIG9mIHRoZSBjb250ZXh0IGluIG51bWJlciBvZiBkaWFsb2cgdHVybnMuIFB1dCBgMGAgdG8gZGlzYWJsZSBleHBpcnkuXG4gKi9cbmNvbnN0IGFwcGVuZENvbnRleHQgPSAoY29udGV4dHMsIHR0bCkgPT4ge1xuICBjb25zdCBleGlzdGluZyA9IGV2ZW50LnN0YXRlLnNlc3Npb24ubmx1Q29udGV4dHMgfHwgW11cbiAgY29uc3QgYWRkID0gY29udGV4dHMuc3BsaXQoJywnKVxuICBjb25zdCBtZXJnZWQgPSBbXG4gICAgLi4uZXhpc3RpbmcsXG4gICAgLi4uYWRkLm1hcCh4ID0+ICh7XG4gICAgICBjb250ZXh0OiB4LFxuICAgICAgdHRsOiBpc05hTihOdW1iZXIodHRsKSkgPyAxMDAwIDogTnVtYmVyKHR0bClcbiAgICB9KSlcbiAgXVxuXG4gIGNvbnN0IGZpbmFsID0gW11cbiAgY29uc3QgdmlzaXRlZCA9IHt9XG4gIGZvciAoY29uc3QgY3R4IG9mIG1lcmdlZCkge1xuICAgIGlmICh2aXNpdGVkW2N0eC5jb250ZXh0XSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgZmluYWwucHVzaChcbiAgICAgIF8uY2hhaW4obWVyZ2VkKVxuICAgICAgICAuZmlsdGVyKHggPT4geC5jb250ZXh0ID09PSBjdHguY29udGV4dClcbiAgICAgICAgLm9yZGVyQnkoJ3R0bCcsICdkZXNjJylcbiAgICAgICAgLmZpcnN0KClcbiAgICAgICAgLnZhbHVlKClcbiAgICApXG4gICAgdmlzaXRlZFtjdHguY29udGV4dF0gPSB0cnVlXG4gIH1cblxuICBldmVudC5zdGF0ZS5zZXNzaW9uLm5sdUNvbnRleHRzID0gZmluYWxcbn1cblxucmV0dXJuIGFwcGVuZENvbnRleHQoYXJncy5jb250ZXh0cywgYXJncy50dGwpXG4iXX0=