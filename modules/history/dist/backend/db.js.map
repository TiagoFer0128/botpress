{"version":3,"sources":["db.ts"],"names":["FLAGS_TABLE_NAME","EVENTS_TABLE_NAME","HistoryDb","constructor","bp","knex","createTableIfNotExists","table","string","primary","messageIds","existingRows","select","from","whereIn","then","rows","map","r","flaggedMessageId","newRows","filter","msgId","includes","batchInsert","messages","del","m","userMessage","id","sessionId","count","offset","filters","incomingMessagesQuery","leftJoin","orderBy","where","direction","flag","whereNotNull","incomingMessageRows","limit","messageGroupsMap","_","forEach","json","get","event","isFlagged","botMessages","outgoingMessagesRows","keys","andWhere","incomingEventId","push","messageGroups","values","sortBy","mg","createdOn","unix","reverse","_getMessageCountWhere","database","getDistinctConversations","botId","to","query","distinct","andWhereNot","fromDate","moment","toDate","date","isBefore","isAfter","queryResults","uniqueConversations","x","getConversationMessageCount","whereParams","messageCountQuery","messageCountObject","pop"],"mappings":"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","sourceRoot":"B:\\bp2\\modules\\history\\src\\backend","sourcesContent":["import * as sdk from 'botpress/sdk'\nimport _ from 'lodash'\nimport { Dictionary } from 'lodash'\nimport moment from 'moment'\n\nimport { MessageGroup, QueryFilters } from '../typings'\n\nconst FLAGS_TABLE_NAME = 'history_flags'\nconst EVENTS_TABLE_NAME = 'events'\n\nexport default class HistoryDb {\n  knex: any\n\n  constructor(private bp: typeof sdk) {\n    this.knex = bp.database\n  }\n\n  initialize = async () => {\n    this.knex.createTableIfNotExists(FLAGS_TABLE_NAME, table => {\n      table.string('flaggedMessageId').primary()\n    })\n  }\n\n  flagMessages = async (messageIds: string[]) => {\n    const existingRows = await this.knex\n      .select()\n      .from(FLAGS_TABLE_NAME)\n      .whereIn('flaggedMessageId', messageIds)\n      .then(rows => rows.map(r => r.flaggedMessageId))\n\n    const newRows = messageIds\n      .filter(msgId => !existingRows.includes(msgId))\n      .map(msgId => ({ flaggedMessageId: msgId }))\n\n    await this.knex.batchInsert(FLAGS_TABLE_NAME, newRows, 30)\n  }\n\n  unflagMessages = async (messages: MessageGroup[]) => {\n    await this.knex\n      .del()\n      .from(FLAGS_TABLE_NAME)\n      .whereIn('flaggedMessageId', messages.map(m => m.userMessage.id))\n  }\n\n  async getDistinctConversations(botId: string, from?: number, to?: number): Promise<string[]> {\n    const query = this.knex\n      .select()\n      .distinct('sessionId')\n      .from(EVENTS_TABLE_NAME)\n      .whereNotNull('sessionId')\n      .andWhere({ botId })\n      .andWhereNot('sessionId', 'like', '%benchmark%') // Those are users created when benchmarking performances\n\n    if (from) {\n      const fromDate = moment.unix(from).toDate()\n      query.andWhere(this.knex.date.isBefore(fromDate, 'createdOn'))\n    }\n    if (to) {\n      const toDate = moment.unix(to).toDate()\n      query.andWhere(this.knex.date.isAfter(toDate, 'createdOn'))\n    }\n\n    const queryResults = await query\n    const uniqueConversations: string[] = queryResults.map(x => x.sessionId)\n\n    return uniqueConversations\n  }\n\n  getMessagesOfConversation = async (\n    sessionId: string,\n    count: number,\n    offset: number,\n    filters: QueryFilters\n  ): Promise<MessageGroup[]> => {\n    const incomingMessagesQuery = this.knex\n      .select('event', 'flaggedMessageId')\n      .from(EVENTS_TABLE_NAME)\n      .leftJoin(FLAGS_TABLE_NAME, `${EVENTS_TABLE_NAME}.incomingEventId`, `${FLAGS_TABLE_NAME}.flaggedMessageId`)\n      .orderBy('createdOn', 'desc')\n      .where({ sessionId, direction: 'incoming' })\n\n    if (filters && filters.flag) {\n      incomingMessagesQuery.whereNotNull(`${FLAGS_TABLE_NAME}.flaggedMessageId`)\n    }\n\n    const incomingMessageRows: any[] = await incomingMessagesQuery.offset(offset).limit(count)\n\n    const messageGroupsMap: Dictionary<MessageGroup> = {}\n    _.forEach(incomingMessageRows, r => {\n      const userMessage: sdk.IO.IncomingEvent = this.knex.json.get(r.event)\n      messageGroupsMap[userMessage.id] = {\n        isFlagged: !!r.flaggedMessageId,\n        userMessage,\n        botMessages: []\n      }\n    })\n\n    const outgoingMessagesRows = await this.knex(EVENTS_TABLE_NAME)\n      .whereIn('incomingEventId', _.keys(messageGroupsMap))\n      .andWhere({ direction: 'outgoing' })\n\n    _.forEach(outgoingMessagesRows, r => {\n      messageGroupsMap[r.incomingEventId].botMessages.push(this.knex.json.get(r.event))\n    })\n\n    const messageGroups = _.values(messageGroupsMap)\n\n    return _.sortBy(messageGroups, (mg: MessageGroup) => moment(mg.userMessage.createdOn).unix()).reverse()\n  }\n\n  async getConversationMessageCount(sessionId: string): Promise<number> {\n    return this._getMessageCountWhere({ sessionId })\n  }\n\n  getConversationMessageGroupCount = async (sessionId: string, filters: QueryFilters) => {\n    return this._getMessageCountWhere({ sessionId, direction: 'incoming' }, filters)\n  }\n\n  private async _getMessageCountWhere(whereParams, filters?: QueryFilters) {\n    const messageCountQuery = this.knex\n      .from(EVENTS_TABLE_NAME)\n      .leftJoin(FLAGS_TABLE_NAME, `${EVENTS_TABLE_NAME}.incomingEventId`, `${FLAGS_TABLE_NAME}.flaggedMessageId`)\n\n    if (filters && filters.flag) {\n      messageCountQuery.whereNotNull(`${FLAGS_TABLE_NAME}.flaggedMessageId`)\n    }\n\n    const messageCountObject = await messageCountQuery.count().where(whereParams)\n    return messageCountObject.pop()['count(*)']\n  }\n}\n"]}